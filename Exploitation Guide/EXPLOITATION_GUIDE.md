# Exploitation Guide
## Step-by-Step Buffer Overflow Exploitation

This guide provides detailed, step-by-step instructions for exploiting the three types of buffer overflow vulnerabilities in the Bank of Pluto application.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Stack Buffer Overflow Exploitation](#stack-buffer-overflow-exploitation)
3. [Format String Vulnerability Exploitation](#format-string-vulnerability-exploitation)
4. [Heap Buffer Overflow Exploitation](#heap-buffer-overflow-exploitation)
5. [Understanding the Results](#understanding-the-results)

---

## Prerequisites

Before starting, ensure:
- Bank of Pluto application is running (`./start.sh`)
- Application accessible at `http://localhost:8080`
- Basic understanding of web browsers and forms

---

## Stack Buffer Overflow Exploitation

### Location
Transfer Funds page (`http://localhost:8080/transfer.html`)

### Step 1: Normal Input Test

**Purpose:** Understand normal application behavior

1. Open your web browser
2. Navigate to: `http://localhost:8080/transfer.html`
3. Fill in the form:
   - **Recipient Account Number:** `1234567890`
   - **Amount:** `100`
   - **Transaction Description:** (leave empty or enter "Test")
4. Click **"Transfer Funds"** button

**Expected Result:**
```
Transfer Confirmation

Recipient Account: 1234567890
Amount: $100
Status: Completed
Transaction ID: TRX-123456

Your transfer has been processed successfully.
```

**What Happened:**
- The application received a valid 10-digit account number
- The data fit within the 50-byte buffer allocated in memory
- The C program processed the transfer successfully
- No memory corruption occurred
- The function returned normally to the calling code

**Memory State (Normal):**
```
Stack Frame:
┌─────────────────────┐
│ Return Address      │  ← Points back to main() (0x400500)
│ ─────────────────── │
│ Frame Pointer       │  ← Valid frame pointer
│ ─────────────────── │
│ buffer[50]          │  ← Contains "1234567890" (10 bytes)
│ "1234567890"        │
│ (40 bytes empty)    │
└─────────────────────┘
```

### Step 2: Buffer Overflow Test

**Purpose:** Trigger a stack buffer overflow

1. Stay on the Transfer Funds page
2. Fill in the form:
   - **Recipient Account Number:** Copy and paste this (100 characters):
     ```
     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
     ```
   - **Amount:** `100`
   - **Transaction Description:** (leave empty)
3. Click **"Transfer Funds"** button

**Expected Result:**
```
Error Code: TRF-5001
Transaction Processing Error
─────────────────────────────────────────────
We encountered an internal error while processing your transfer request.
Please verify that the recipient account number is correct and try again.

If the problem persists, please contact our support team at:
bank@pluto.co or call 1-800-BANK-PLT

Reference ID: [random-id]
Timestamp: [current-time]
```

**What Happened:**
- The application received 100 characters in the recipient field
- The backend C program has a buffer of only 50 bytes
- The `strcpy()` function copied all 100 characters without checking
- 50 bytes overflowed beyond the buffer boundary
- The overflow corrupted:
  1. Other local variables (if any)
  2. The saved frame pointer
  3. **The return address** (critical!)
- When the function tried to return, it jumped to an invalid memory address
- The CPU raised a segmentation fault (SIGSEGV)
- The program terminated with exit code 133

**Memory State (Overflow):**
```
Stack Frame After Overflow:
┌─────────────────────┐
│ 0x41414141 (ret)    │  ← RETURN ADDRESS CORRUPTED!
│ (Invalid address)   │     Contains 'AAAA' (0x41 = 'A')
│ ─────────────────── │
│ 0x41414141 (ebp)    │  ← Frame pointer corrupted
│ ─────────────────── │
│ AAAA...AAAA         │  ← 100 bytes written to 50-byte buffer
│ (overflowed!)       │
└─────────────────────┘

Result: Segmentation Fault (SIGSEGV)
Exit Code: 133
```

**Technical Explanation:**
- Exit code 133 = 128 + 5 (SIGSEGV signal number)
- SIGSEGV indicates invalid memory access
- The program attempted to execute code at address 0x41414141
- This address doesn't contain valid code, causing termination
- In a real attack, the return address would point to attacker-controlled code

### Step 3: Understanding the Impact

**Why This is Dangerous:**
1. **Program Crash:** Denial of service attack
2. **Information Disclosure:** May leak memory contents
3. **Code Execution:** With proper payload, attacker code can execute
4. **System Compromise:** If running with elevated privileges, full system access

**Real Attack Scenario:**
Instead of 'A' characters, an attacker would send:
```
[NOPSLED] + [SHELLCODE] + [PADDING] + [RETURN_ADDRESS]
```
Where:
- NOPSLED: No-operation instructions (helps targeting)
- SHELLCODE: Malicious code (reverse shell, file access, etc.)
- PADDING: Fills buffer to reach return address
- RETURN_ADDRESS: Points to the shellcode location

---

## Format String Vulnerability Exploitation

### Location
Account Statement page (`http://localhost:8080/statement.html`)

### Step 1: Normal Input Test

**Purpose:** Understand normal statement generation

1. Navigate to: `http://localhost:8080/statement.html`
2. Fill in the form:
   - **Account Number:** `1234567890`
   - **Statement Format:** `PDF`
3. Click **"Generate Statement"** button

**Expected Result:**
```
BANK OF PLUTO
Account Statement
Generated: 2024-12-15

Account Number: 1234567890
Statement Period: December 2024
Format: PDF

TRANSACTION HISTORY

Date          Description              Amount        Balance
2024-12-15    Salary Deposit           $3,000.00     $12,450.00
2024-12-10    Online Purchase          -$150.00      $9,450.00
2024-12-05    Bill Payment             -$200.00      $9,600.00
2024-12-01    Interest Earned          $50.00        $9,800.00

Current Balance: $12,450.00

For inquiries, contact: bank@pluto.co
```

**What Happened:**
- The application received "PDF" as the format string
- The C program used `printf(format)` where format = "PDF"
- `printf()` treated "PDF" as a literal string (no format specifiers)
- The string "PDF" was printed normally
- No special interpretation occurred
- The statement was generated successfully

**Memory State (Normal):**
```
Stack during printf():
┌─────────────────────┐
│ Format string:      │  ← "PDF" (literal string)
│ "PDF"               │
│ ─────────────────── │
│ Other stack data    │  ← Not accessed
└─────────────────────┘

printf() output: "PDF"
```

### Step 2: Format String Attack - Basic Memory Leak

**Purpose:** Leak memory contents from the stack

1. Stay on the Account Statement page
2. Fill in the form:
   - **Account Number:** `1234567890`
   - **Statement Format:** `%x %x %x %x %x`
3. Click **"Generate Statement"** button

**Expected Result:**
```
BANK OF PLUTO
Account Statement
Generated: 2024-12-15

Account Number: 1234567890
Statement Period: December 2024
Format: 6b9eec7e 6b9eec98 6b9eec7e 1 36353433

TRANSACTION HISTORY
...
```

**What Happened:**
- The application received `%x %x %x %x %x` as the format string
- The C program executed `printf("%x %x %x %x %x")`
- `printf()` interpreted `%x` as a format specifier (hexadecimal integer)
- For each `%x`, `printf()` read the next value from the stack
- These values were displayed as hexadecimal numbers
- **Memory contents were leaked!**

**Memory State (Format String Attack):**
```
Stack during printf():
┌─────────────────────┐
│ Format string:      │  ← "%x %x %x %x %x"
│ "%x %x %x %x %x"    │
│ ─────────────────── │
│ Stack value 1:      │  ← 0x6b9eec7e (read by first %x)
│ 0x6b9eec7e          │
│ ─────────────────── │
│ Stack value 2:      │  ← 0x6b9eec98 (read by second %x)
│ 0x6b9eec98          │
│ ─────────────────── │
│ Stack value 3:      │  ← 0x6b9eec7e (read by third %x)
│ 0x6b9eec7e          │
│ ─────────────────── │
│ ...                 │
└─────────────────────┘

printf() output: "6b9eec7e 6b9eec98 6b9eec7e 1 36353433"
```

**Technical Explanation:**
- `%x` format specifier reads a 32-bit integer from the stack
- Displays it as hexadecimal (base 16)
- Each `%x` advances the stack pointer
- Values displayed are actual memory contents
- May include:
  - Function parameters
  - Local variables
  - Return addresses
  - Sensitive data

### Step 3: Format String Attack - Advanced (Pointer Leak)

**Purpose:** Leak memory addresses using pointer format specifier

1. Stay on the Account Statement page
2. Fill in the form:
   - **Account Number:** `1234567890`
   - **Statement Format:** `%p %p %p %p %p %p %p`
3. Click **"Generate Statement"** button

**Expected Result:**
```
BANK OF PLUTO
Account Statement
Generated: 2024-12-15

Account Number: 1234567890
Statement Period: December 2024
Format: 0x16d31ec7e 0x16d31ec98 0x16d31ec7e 0x3231000000000001 ...

TRANSACTION HISTORY
...

─────────────────────────────────────────────────────────────
Statement Generation Complete
─────────────────────────────────────────────────────────────
Format: %p %p %p %p %p %p %p
Note: Advanced format processing detected.
Memory addresses and stack contents have been included in output.

System Information Leaked:
• Stack pointer values: Visible in format output above
• Memory layout: Revealed through pointer addresses
• Potential sensitive data: May be present in stack dump

Note: This output contains low-level system information.
─────────────────────────────────────────────────────────────
```

**What Happened:**
- The application received `%p %p %p %p %p %p %p` as the format string
- `%p` format specifier reads pointer values from the stack
- Displays addresses in hexadecimal with `0x` prefix
- Reveals memory layout and addresses
- Advanced payloads trigger additional information disclosure

**Memory State (Advanced Format String):**
```
Stack during printf():
┌─────────────────────┐
│ Format string:      │  ← "%p %p %p %p %p %p %p"
│ "%p %p %p %p..."    │
│ ─────────────────── │
│ Pointer 1:          │  ← 0x16d31ec7e (stack address)
│ 0x16d31ec7e         │
│ ─────────────────── │
│ Pointer 2:          │  ← 0x16d31ec98 (another address)
│ 0x16d31ec98         │
│ ─────────────────── │
│ ...                 │
└─────────────────────┘

printf() output: "0x16d31ec7e 0x16d31ec98 0x16d31ec7e ..."
```

**Why This is Dangerous:**
- Memory addresses can be used to bypass ASLR
- Stack layout revealed helps in crafting exploits
- Sensitive data may be present in leaked values
- Can enable more sophisticated attacks

### Step 4: Understanding Format Specifiers

**Common Format Specifiers:**

| Specifier | Meaning | What It Does |
|-----------|---------|--------------|
| `%x` | Hexadecimal | Reads integer from stack, displays as hex |
| `%p` | Pointer | Reads pointer from stack, displays address |
| `%s` | String | Reads address from stack, displays string at that address |
| `%d` | Decimal | Reads integer from stack, displays as decimal |
| `%n` | Write | Writes number of characters printed to address |

**Dangerous Specifiers:**
- `%n`: Can write to arbitrary memory addresses
- `%s`: May crash if address is invalid, or leak strings
- Multiple specifiers: Can read large amounts of memory

---

## Heap Buffer Overflow Exploitation

### Location
Transaction History page (`http://localhost:8080/history.html`)

### Step 1: Normal Input Test

**Purpose:** Understand normal transaction history retrieval

1. Navigate to: `http://localhost:8080/history.html`
2. Fill in the form:
   - **Account Number:** `1234567890`
   - **Filter Transactions:** `deposit`
   - **Number of Records:** `10`
3. Click **"View History"** button

**Expected Result:**
```
BANK OF PLUTO
Transaction History

Account Number: 1234567890
Filter: deposit
Records Displayed: 10

Date          Type        Amount        Balance
2024-12-15    Deposit     $500.00       $12,450.00
2024-12-10    Transfer    -$200.00      $11,950.00
2024-12-05    Withdraw    -$100.00      $12,150.00

For inquiries, contact: bank@pluto.co
```

**What Happened:**
- The application received valid input for all fields
- The C program allocated 100 bytes on the heap for the filter
- The filter string "deposit" (7 bytes) fit within the allocation
- `strcpy()` copied the filter successfully
- No memory corruption occurred
- The function processed and displayed transaction history
- Memory was properly freed after use

**Memory State (Normal):**
```
Heap Allocation:
┌─────────────────────┐
│ Heap Chunk Metadata │  ← Size, flags, etc.
│ ─────────────────── │
│ filter_buffer[100] │  ← Allocated 100 bytes
│ "deposit"           │  ← 7 bytes used
│ (93 bytes unused)   │
└─────────────────────┘

Result: Normal operation, no corruption
```

### Step 2: Heap Buffer Overflow Test

**Purpose:** Trigger a heap-based buffer overflow

1. Stay on the Transaction History page
2. Fill in the form:
   - **Account Number:** `1234567890`
   - **Filter Transactions:** Copy and paste this (200 characters):
     ```
     BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
     ```
   - **Number of Records:** `10`
3. Click **"View History"** button

**Expected Result:**
```
BANK OF PLUTO
Transaction History

Account Number: 1234567890
Filter: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Records Displayed: 10

Date          Type        Amount        Balance
2024-12-15    Deposit     $500.00       $12,450.00
2024-12-10    Transfer    -$200.00      $11,950.00
2024-12-05    Withdraw    -$100.00      $12,150.00

Error Code: HIS-6001
Transaction History Retrieval Error
─────────────────────────────────────────────
We encountered an internal error while retrieving your transaction history.
The filter criteria may be too complex or contain invalid characters.

Please try:
• Using simpler filter terms
• Reducing the number of characters in your filter
• Contacting support if the issue persists

Reference ID: [random-id]
Timestamp: [current-time]
```

**What Happened:**
- The application received 200 characters in the filter field
- The C program allocated 100 bytes on the heap for the filter
- The `strcpy()` function copied all 200 characters without checking
- 100 bytes overflowed beyond the allocated heap chunk
- The overflow corrupted:
  1. Adjacent heap chunks (if any)
  2. **Heap metadata structures** (size, flags, pointers)
  3. Other heap-allocated data
- When the program tried to free the memory or access heap structures, it detected corruption
- The heap manager raised an abort signal
- The program terminated with exit code 134

**Memory State (Heap Overflow):**
```
Heap Before Overflow:
┌─────────────────────┐
│ Chunk Metadata      │  ← Size: 100 bytes
│ ─────────────────── │
│ filter_buffer[100]  │  ← Allocated space
│ (empty)             │
└─────────────────────┘
┌─────────────────────┐
│ Next Chunk Metadata │  ← Adjacent chunk
└─────────────────────┘

Heap After Overflow (200 bytes written):
┌─────────────────────┐
│ Chunk Metadata      │  ← May be corrupted
│ ─────────────────── │
│ BBBB...BBBB         │  ← 200 bytes written!
│ (overflowed!)        │
└─────────────────────┘
┌─────────────────────┐
│ [CORRUPTED]         │  ← Metadata overwritten!
│ Next Chunk Metadata │     Heap structure broken
└─────────────────────┘

Result: Heap corruption detected
Exit Code: 134 (Abort signal)
```

**Technical Explanation:**
- Exit code 134 = 128 + 6 (SIGABRT signal number)
- SIGABRT indicates abnormal termination
- Heap manager detected metadata corruption
- Attempted to maintain heap integrity by aborting
- In a real attack, this could lead to:
  - Arbitrary write primitives
  - Use-after-free vulnerabilities
  - Code execution via function pointer overwrite

### Step 3: Understanding Heap Structure

**Heap Chunk Layout:**
```
Heap Chunk:
┌─────────────────────┐
│ Previous Size       │  ← Metadata (if previous chunk free)
│ ─────────────────── │
│ Chunk Size          │  ← Current chunk size + flags
│ ─────────────────── │
│ User Data           │  ← Your allocated buffer
│ [100 bytes]         │
│ ─────────────────── │
│ Next Chunk Metadata │  ← Adjacent chunk information
└─────────────────────┘
```

**What Gets Corrupted:**
- Chunk size field: Heap manager uses this to find next chunk
- Flags: Indicate if chunk is in use or free
- Forward/backward pointers: Used in free chunk lists
- Adjacent chunk metadata: Critical for heap operations

---

## Understanding the Results

### Comparison Table

| Vulnerability | Normal Input | Overflow Input | Exit Code | What Gets Corrupted |
|---------------|-------------|----------------|-----------|---------------------|
| **Stack Overflow** | Processes successfully | Segmentation fault | 133 | Return address, frame pointer |
| **Format String** | Prints format literally | Leaks memory values | 0 (but leaks data) | No corruption, but information disclosure |
| **Heap Overflow** | Processes successfully | Abort/corruption | 134 | Heap metadata, adjacent chunks |

### Exit Codes Explained

**Exit Code 133 (Stack Overflow):**
- 128 + 5 = SIGSEGV (Segmentation Violation)
- Invalid memory access attempted
- Return address pointed to invalid location
- CPU protection fault triggered

**Exit Code 134 (Heap Overflow):**
- 128 + 6 = SIGABRT (Abort Signal)
- Heap corruption detected
- Memory manager detected invalid state
- Program aborted to prevent further corruption

**Exit Code 0 (Format String - Normal):**
- Program completed normally
- No crash occurred
- But sensitive data was leaked
- Information disclosure without crash

### Memory Corruption Visualization

**Stack Overflow:**
```
Before:  [Buffer][Frame Ptr][Return Addr]
After:   [OVERFLOW][CORRUPTED][CORRUPTED]
Result:  Invalid return → Crash
```

**Heap Overflow:**
```
Before:  [Chunk][Metadata][Next Chunk]
After:   [OVERFLOW][CORRUPTED][CORRUPTED]
Result:  Heap corruption → Abort
```

**Format String:**
```
Before:  [Stack Values Hidden]
After:   [Stack Values Exposed]
Result:  Information Leaked
```

---

## Key Takeaways

### What You Learned

1. **Stack Buffer Overflow:**
   - Occurs when data exceeds stack-allocated buffer
   - Corrupts return address
   - Causes segmentation fault
   - Can lead to code execution

2. **Format String Vulnerability:**
   - User input interpreted as format string
   - Can read memory contents
   - Information disclosure attack
   - No crash, but data leaked

3. **Heap Buffer Overflow:**
   - Occurs when data exceeds heap-allocated buffer
   - Corrupts heap metadata
   - Causes abort signal
   - Can lead to arbitrary writes

### Security Implications

All three vulnerabilities demonstrate:
- Importance of input validation
- Need for bounds checking
- Risk of unsafe functions
- Necessity of secure coding practices

### Next Steps

1. Experiment with different payload lengths
2. Try combining multiple techniques
3. Study the C source code to understand internals
4. Learn about exploitation payloads
5. Research mitigation techniques

---

*For educational purposes only. Use responsibly and ethically.*

