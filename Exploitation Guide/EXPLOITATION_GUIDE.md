# Exploitation Guide
## Step-by-Step UI-Based Buffer Overflow Exploitation

This guide provides detailed, step-by-step instructions for exploiting buffer overflow vulnerabilities through the Bank of Pluto web interface. All exploitation is performed directly in your web browser.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Stack Buffer Overflow Exploitation (Transfer Funds)](#stack-buffer-overflow-exploitation-transfer-funds)
3. [Format String Vulnerability Exploitation (Account Statement)](#format-string-vulnerability-exploitation-account-statement)
4. [Heap Buffer Overflow Exploitation (Transaction History)](#heap-buffer-overflow-exploitation-transaction-history)
5. [Understanding the Results](#understanding-the-results)

---

## Prerequisites

**Before starting, ensure:**
1. Bank of Pluto application is running
   - Open terminal
   - Navigate to: `cd ~/Bank-of-Pluto/buffer-overflow`
   - Run: `./start.sh`
   - Wait for "Server running at: http://localhost:8080" message

2. Web browser ready
   - Use Chrome, Firefox, Safari, or Edge
   - Have the browser open and ready

3. Application accessible
   - Open: `http://localhost:8080` in your browser
   - You should see the Bank of Pluto homepage

---

## Stack Buffer Overflow Exploitation (Transfer Funds)

### Accessing the Transfer Funds Page

1. **Open your web browser**
2. **Navigate to:** `http://localhost:8080`
3. **Click on "Transfer Funds"** in the navigation menu
   - You should see the Transfer Funds form
   - Form has three fields: Recipient Account Number, Amount, and Transaction Description

### Test 1: Normal Input (Baseline Test)

**Objective:** Establish normal application behavior for comparison

**Steps:**
1. In the **Recipient Account Number** field, type: `1234567890`
   - This is a valid 10-digit account number
   - The field should accept it without errors
2. In the **Amount** field, type: `100`
3. Leave **Transaction Description** empty (or type "Test")
4. Click the **"Transfer Funds"** button

**What You'll See in the Browser:**
- A green success box appears below the form
- The message displays:
  ```
  Transfer Confirmation

  Recipient Account: 1234567890
  Amount: $100
  Status: Completed
  Transaction ID: TRX-[numbers]

  Your transfer has been processed successfully.
  ```

**What Happened Behind the Scenes:**
- Your browser sent the form data to the server
- The PHP script received: `recipient=1234567890&amount=100`
- The C program `stack_overflow` was executed with these parameters
- The 10-character account number fit perfectly in the 50-byte buffer
- No memory corruption occurred
- The function completed normally and returned

**Memory State (Normal Operation):**
```
Stack Memory Layout:
┌─────────────────────┐
│ Return Address      │  ← Valid address (0x400500)
│ ─────────────────── │
│ Frame Pointer       │  ← Valid frame pointer
│ ─────────────────── │
│ buffer[50]          │  ← Your data here
│ "1234567890"        │  ← 10 bytes used, 40 bytes free
│ (empty space)       │
└─────────────────────┘
Status: ✅ Normal execution, no issues
```

### Test 2: Buffer Overflow Attack

**Objective:** Trigger a stack buffer overflow through the web interface

**Steps:**
1. **Stay on the Transfer Funds page** (refresh if needed)
2. In the **Recipient Account Number** field, you need to enter 100+ characters
   
   **Easy Method - Copy and Paste:**
   - Copy this entire string (100 'A' characters):
     ```
     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
     ```
   - Paste it into the Recipient Account Number field
   - The field will show all the 'A' characters

3. In the **Amount** field, type: `100`
4. Leave **Transaction Description** empty
5. Click the **"Transfer Funds"** button

**What You'll See in the Browser:**
- A red error box appears below the form
- The error message displays:
  ```
  Error Code: TRF-5001
  Transaction Processing Error
  ─────────────────────────────────────────────
  We encountered an internal error while processing your transfer request.
  Please verify that the recipient account number is correct and try again.

  If the problem persists, please contact our support team at:
  bank@pluto.co or call 1-800-BANK-PLT

  Reference ID: [random-id]
  Timestamp: [current-time]
  ```

**What Happened Behind the Scenes:**
- Your browser sent 100+ characters in the recipient field
- The PHP script passed this to the C program
- The C program has a buffer of only 50 bytes
- The `strcpy()` function copied all 100 characters without checking length
- 50 bytes overflowed beyond the buffer boundary
- The overflow corrupted the return address on the stack
- When the function tried to return, it jumped to address 0x41414141 ('AAAA' in hex)
- This is an invalid memory address
- The operating system raised a segmentation fault
- The program terminated with exit code 133

**Memory State (After Overflow):**
```
Stack Memory Layout After Overflow:
┌─────────────────────┐
│ 0x41414141 (ret)    │  ← CORRUPTED! Contains 'AAAA'
│ (Invalid address)   │     Program tries to jump here
│ ─────────────────── │
│ 0x41414141 (ebp)    │  ← Frame pointer corrupted
│ ─────────────────── │
│ AAAA...AAAA         │  ← 100 bytes in 50-byte buffer
│ (50 bytes overflow) │     Overflowed into adjacent memory
└─────────────────────┘
Status: ❌ Segmentation Fault (SIGSEGV)
Exit Code: 133
```

**Visual Representation:**
```
Normal:  [Buffer: 50 bytes][Return Addr: Valid]
         └─ "1234567890" fits perfectly

Overflow: [Buffer: 50 bytes][Return Addr: CORRUPTED]
          └─ 100 'A's overflow ────────────┘
```

### Understanding the Stack Overflow

**Why the Application Crashed:**
1. The buffer was designed to hold 50 bytes
2. You provided 100 bytes of data
3. The extra 50 bytes wrote over the return address
4. The return address became 0x41414141 (invalid)
5. CPU tried to execute code at invalid address
6. Operating system killed the process (segmentation fault)

**Real-World Impact:**
- In a production system, this would cause a denial of service
- With a crafted payload, an attacker could execute arbitrary code
- The attacker's code would run with the same privileges as the application
- This could lead to full system compromise

---

## Format String Vulnerability Exploitation (Account Statement)

### Accessing the Account Statement Page

1. **In your web browser**, navigate to: `http://localhost:8080`
2. **Click on "Account Statement"** in the navigation menu
   - You should see the Account Statement form
   - Form has two fields: Account Number and Statement Format

### Test 1: Normal Input (Baseline Test)

**Objective:** Understand normal statement generation

**Steps:**
1. In the **Account Number** field, type: `1234567890`
2. In the **Statement Format** field, type: `PDF`
3. Click the **"Generate Statement"** button

**What You'll See in the Browser:**
- A green success box appears
- The statement displays:
  ```
  BANK OF PLUTO
  Account Statement
  Generated: 2024-12-15

  Account Number: 1234567890
  Statement Period: December 2024
  Format: PDF

  TRANSACTION HISTORY

  Date          Description              Amount        Balance
  2024-12-15    Salary Deposit           $3,000.00     $12,450.00
  2024-12-10    Online Purchase          -$150.00      $9,450.00
  2024-12-05    Bill Payment             -$200.00      $9,600.00
  2024-12-01    Interest Earned          $50.00        $9,800.00

  Current Balance: $12,450.00

  For inquiries, contact: bank@pluto.co
  ```

**What Happened Behind the Scenes:**
- Your browser sent: `account=1234567890&format=PDF`
- The PHP script executed the C program `format_string`
- The C program called `printf(format)` where format = "PDF"
- Since "PDF" contains no format specifiers, it was printed literally
- The statement was generated normally
- No memory access occurred beyond the format string

**Memory State (Normal Operation):**
```
printf() Execution:
Format String: "PDF" (literal string, no specifiers)
Stack Values: [Not accessed]
Output: "PDF"
Status: ✅ Normal string printing
```

### Test 2: Format String Attack - Memory Leak

**Objective:** Exploit format string vulnerability to leak memory contents

**Steps:**
1. **Stay on the Account Statement page** (refresh if needed)
2. In the **Account Number** field, type: `1234567890`
3. In the **Statement Format** field, type: `%x %x %x %x %x`
   - Type exactly: percent sign, x, space, percent sign, x, space, etc.
   - This is: `%x %x %x %x %x` (5 format specifiers)
4. Click the **"Generate Statement"** button

**What You'll See in the Browser:**
- A green success box appears (no error!)
- The statement displays, but notice the Format field:
  ```
  BANK OF PLUTO
  Account Statement
  Generated: 2024-12-15

  Account Number: 1234567890
  Statement Period: December 2024
  Format: 6b9eec7e 6b9eec98 6b9eec7e 1 36353433
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          These are HEXADECIMAL VALUES from memory!

  TRANSACTION HISTORY
  ...
  ```

**What Happened Behind the Scenes:**
- Your browser sent: `account=1234567890&format=%x %x %x %x %x`
- The C program executed `printf("%x %x %x %x %x")`
- `printf()` interpreted each `%x` as a format specifier
- Each `%x` reads the next 32-bit value from the stack
- These values were displayed as hexadecimal numbers
- **Memory contents were leaked!**

**Memory State (Format String Attack):**
```
printf() Execution:
Format String: "%x %x %x %x %x" (5 format specifiers)
Stack Values Accessed:
┌─────────────────────┐
│ Value 1: 0x6b9eec7e │  ← Read by first %x
│ Value 2: 0x6b9eec98 │  ← Read by second %x
│ Value 3: 0x6b9eec7e │  ← Read by third %x
│ Value 4: 0x1        │  ← Read by fourth %x
│ Value 5: 0x36353433 │  ← Read by fifth %x
└─────────────────────┘
Output: "6b9eec7e 6b9eec98 6b9eec7e 1 36353433"
Status: ⚠️ Memory disclosure - sensitive data leaked
```

**What Those Hex Values Mean:**
- `0x6b9eec7e` - Could be a stack address, function parameter, or local variable
- `0x6b9eec98` - Another memory address or value
- `0x1` - Could be a flag, counter, or small integer
- `0x36353433` - Could be ASCII data or a pointer

### Test 3: Advanced Format String - Pointer Leak

**Objective:** Leak memory addresses using pointer format specifiers

**Steps:**
1. **Stay on the Account Statement page**
2. In the **Account Number** field, type: `1234567890`
3. In the **Statement Format** field, type: `%p %p %p %p %p %p %p`
   - Type: percent sign, p, space, repeated 7 times
   - This uses the `%p` format specifier (pointer format)
4. Click the **"Generate Statement"** button

**What You'll See in the Browser:**
- A green success box appears
- The statement shows pointer addresses in the Format field:
  ```
  Format: 0x16d31ec7e 0x16d31ec98 0x16d31ec7e 0x3231000000000001 ...
  ```
- Additionally, you may see an information box:
  ```
  ─────────────────────────────────────────────────────────────
  Statement Generation Complete
  ─────────────────────────────────────────────────────────────
  Format: %p %p %p %p %p %p %p
  Note: Advanced format processing detected.
  Memory addresses and stack contents have been included in output.

  System Information Leaked:
  • Stack pointer values: Visible in format output above
  • Memory layout: Revealed through pointer addresses
  • Potential sensitive data: May be present in stack dump

  Note: This output contains low-level system information.
  ─────────────────────────────────────────────────────────────
  ```

**What Happened Behind the Scenes:**
- The `%p` format specifier reads pointer values from the stack
- Displays them in hexadecimal with `0x` prefix
- Reveals the memory layout of the program
- Advanced payloads trigger additional information disclosure
- The system detected the advanced attack and provided context

**Why This is More Dangerous:**
- Memory addresses can be used to bypass ASLR (Address Space Layout Randomization)
- Reveals stack layout for crafting more sophisticated attacks
- May contain sensitive data like passwords, keys, or tokens
- Enables calculation of exact memory locations for exploitation

---

## Heap Buffer Overflow Exploitation (Transaction History)

### Accessing the Transaction History Page

1. **In your web browser**, navigate to: `http://localhost:8080`
2. **Click on "Transaction History"** in the navigation menu
   - You should see the Transaction History form
   - Form has three fields: Account Number, Filter Transactions, and Number of Records

### Test 1: Normal Input (Baseline Test)

**Objective:** Establish normal transaction history retrieval

**Steps:**
1. In the **Account Number** field, type: `1234567890`
2. In the **Filter Transactions** field, type: `deposit`
3. In the **Number of Records** field, type: `10`
4. Click the **"View History"** button

**What You'll See in the Browser:**
- A green success box appears
- The transaction history displays:
  ```
  BANK OF PLUTO
  Transaction History

  Account Number: 1234567890
  Filter: deposit
  Records Displayed: 10

  Date          Type        Amount        Balance
  2024-12-15    Deposit     $500.00       $12,450.00
  2024-12-10    Transfer    -$200.00      $11,950.00
  2024-12-05    Withdraw    -$100.00      $12,150.00

  For inquiries, contact: bank@pluto.co
  ```

**What Happened Behind the Scenes:**
- Your browser sent: `account=1234567890&filter=deposit&limit=10`
- The PHP script executed the C program `heap_overflow`
- The C program allocated 100 bytes on the heap using `malloc(100)`
- The filter string "deposit" (7 bytes) fit within the allocation
- `strcpy()` copied the filter successfully
- No heap corruption occurred
- The function processed and displayed the history
- Memory was properly freed after use

**Memory State (Normal Operation):**
```
Heap Allocation:
┌─────────────────────┐
│ Heap Chunk Metadata │  ← Size: 100 bytes, flags, etc.
│ ─────────────────── │
│ filter_buffer[100]  │  ← Allocated space
│ "deposit"           │  ← 7 bytes used, 93 bytes free
│ (unused space)       │
└─────────────────────┘
Status: ✅ Normal heap operation
```

### Test 2: Heap Buffer Overflow Attack

**Objective:** Trigger a heap-based buffer overflow through the web interface

**Steps:**
1. **Stay on the Transaction History page** (refresh if needed)
2. In the **Account Number** field, type: `1234567890`
3. In the **Filter Transactions** field, you need to enter 200+ characters
   
   **Easy Method - Copy and Paste:**
   - Copy this entire string (200 'B' characters):
     ```
     BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
     ```
   - Paste it into the Filter Transactions field
   - The field will show all the 'B' characters

4. In the **Number of Records** field, type: `10`
5. Click the **"View History"** button

**What You'll See in the Browser:**
- The transaction history may partially display
- Then a red error box appears:
  ```
  Error Code: HIS-6001
  Transaction History Retrieval Error
  ─────────────────────────────────────────────
  We encountered an internal error while retrieving your transaction history.
  The filter criteria may be too complex or contain invalid characters.

  Please try:
  • Using simpler filter terms
  • Reducing the number of characters in your filter
  • Contacting support if the issue persists

  Reference ID: [random-id]
  Timestamp: [current-time]
  ```

**What Happened Behind the Scenes:**
- Your browser sent 200+ characters in the filter field
- The C program allocated 100 bytes on the heap using `malloc(100)`
- The `strcpy()` function copied all 200 characters without checking
- 100 bytes overflowed beyond the allocated heap chunk
- The overflow corrupted heap metadata structures
- When the program tried to free memory or access heap structures, corruption was detected
- The heap manager raised an abort signal to prevent further damage
- The program terminated with exit code 134

**Memory State (After Heap Overflow):**
```
Heap Before Overflow:
┌─────────────────────┐
│ Chunk Size: 100     │  ← Metadata
│ Flags: In Use       │
│ ─────────────────── │
│ filter_buffer[100]  │  ← Allocated space
│ (empty)             │
└─────────────────────┘
┌─────────────────────┐
│ Next Chunk Metadata │  ← Adjacent chunk
└─────────────────────┘

Heap After Overflow (200 bytes written):
┌─────────────────────┐
│ [CORRUPTED]         │  ← Metadata overwritten!
│ Chunk Size: ???     │     Heap structure broken
│ ─────────────────── │
│ BBBB...BBBB         │  ← 200 bytes written!
│ (100 bytes overflow)│     Overflowed into next chunk
└─────────────────────┘
┌─────────────────────┐
│ [CORRUPTED]         │  ← Adjacent chunk metadata
│ Next Chunk Metadata │     Also corrupted
└─────────────────────┘
Status: ❌ Heap corruption detected
Exit Code: 134 (SIGABRT)
```

**Visual Representation:**
```
Normal:  [Heap Chunk: 100 bytes][Next Chunk]
         └─ "deposit" fits perfectly

Overflow: [Heap Chunk: 100 bytes][Next Chunk: CORRUPTED]
          └─ 200 'B's overflow ────────────┘
```

### Understanding the Heap Overflow

**Why the Application Crashed:**
1. The heap chunk was allocated for 100 bytes
2. You provided 200 bytes of data
3. The extra 100 bytes wrote over the next chunk's metadata
4. Heap manager detected metadata corruption
5. To prevent further damage, the program was aborted
6. Exit code 134 indicates abnormal termination (SIGABRT)

**Real-World Impact:**
- Heap corruption can lead to arbitrary write primitives
- Attackers can overwrite function pointers
- Can cause use-after-free vulnerabilities
- May enable code execution through heap manipulation

---

## Understanding the Results

### Comparison: Normal vs. Overflow

| Test | Input Length | Result in Browser | Exit Code | What Happened |
|------|--------------|-------------------|-----------|---------------|
| **Stack - Normal** | 10 chars | ✅ Success message | 0 | Normal processing |
| **Stack - Overflow** | 100+ chars | ❌ Error TRF-5001 | 133 | Return address corrupted |
| **Format - Normal** | "PDF" | ✅ Statement displayed | 0 | Normal string printing |
| **Format - Attack** | "%x %x %x" | ⚠️ Hex values shown | 0 | Memory leaked (no crash) |
| **Heap - Normal** | 7 chars | ✅ History displayed | 0 | Normal heap operation |
| **Heap - Overflow** | 200+ chars | ❌ Error HIS-6001 | 134 | Heap metadata corrupted |

### What Each Exit Code Means

**Exit Code 0 (Success):**
- Program completed normally
- No errors occurred
- For format string attacks, data may still be leaked

**Exit Code 133 (Stack Overflow):**
- Segmentation fault (SIGSEGV)
- Invalid memory access attempted
- Return address pointed to invalid location
- Program tried to execute code at bad address

**Exit Code 134 (Heap Overflow):**
- Abort signal (SIGABRT)
- Heap corruption detected
- Memory manager found invalid heap state
- Program aborted to prevent further damage

### Visual Summary

**Stack Buffer Overflow:**
```
Browser Input: 100 'A' characters
    ↓
Web Form Submission
    ↓
PHP Script
    ↓
C Program (buffer[50])
    ↓
strcpy() copies 100 bytes
    ↓
50 bytes overflow
    ↓
Return address corrupted
    ↓
Segmentation Fault
    ↓
Browser shows: Error TRF-5001
```

**Format String Vulnerability:**
```
Browser Input: "%x %x %x %x"
    ↓
Web Form Submission
    ↓
PHP Script
    ↓
C Program printf(format)
    ↓
printf() interprets %x
    ↓
Reads values from stack
    ↓
Displays as hexadecimal
    ↓
Browser shows: Hex values in format field
```

**Heap Buffer Overflow:**
```
Browser Input: 200 'B' characters
    ↓
Web Form Submission
    ↓
PHP Script
    ↓
C Program malloc(100)
    ↓
strcpy() copies 200 bytes
    ↓
100 bytes overflow
    ↓
Heap metadata corrupted
    ↓
Abort Signal
    ↓
Browser shows: Error HIS-6001
```

---

## Key Takeaways

### What You've Learned

1. **Stack Buffer Overflow:**
   - Triggered through web form input
   - Causes program crash (segmentation fault)
   - Corrupts return address on stack
   - Visible in browser as error message

2. **Format String Vulnerability:**
   - Exploited through format field
   - Leaks memory contents without crashing
   - Information disclosure attack
   - Visible in browser as hex values

3. **Heap Buffer Overflow:**
   - Triggered through filter field
   - Causes program abort
   - Corrupts heap metadata structures
   - Visible in browser as error message

### Security Lessons

- **Input validation is critical:** All user input must be validated
- **Bounds checking is essential:** Never trust input size
- **Unsafe functions are dangerous:** `strcpy()`, `gets()`, `sprintf()` should be avoided
- **Web interfaces are attack vectors:** UI input can trigger backend vulnerabilities
- **Error messages reveal information:** Even error codes can aid attackers

### Next Steps for Learning

1. Try different payload lengths to find exact overflow points
2. Experiment with different format specifiers (`%s`, `%n`, `%p`)
3. Study the C source code to understand the vulnerabilities
4. Learn about exploitation payloads and shellcode
5. Research mitigation techniques and secure coding practices

---

*This guide is for educational purposes only. Use this knowledge responsibly and ethically. Only test on systems you own or have explicit permission to test.*
